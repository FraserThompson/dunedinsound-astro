---
/**
 * Menu of all gigs on the website, sorted by date and month.
 *
 * It responds to shuffle events to filter its items.
 *
 * Props:
 *  selected (optional): it will show the artists under that gig.
 */
import { loadAndFormatCollection, sortGigs } from 'src/util/collection.ts'
import { gigLink, artistLink, yearLink, monthLink, yearsMenuWrapper, artistsMenuWrapper } from './GigsMenu.css'
import { makeHash, artistsToString } from 'src/util/helpers'
import DropdownMenu from '../DropdownMenu'
import { theme } from 'src/Theme.css'
import { MenuLi } from '../Menu.css'
import { MenuWrapper } from '../Menu.css'

interface Props {
	selected?: string
}

const gigs = await loadAndFormatCollection('gig')
const sortedGigs = sortGigs(gigs)

const { selected } = Astro.props
---

<DropdownMenu
	list={Object.keys(sortedGigs)
		.reverse()
		.map((year) => ({
			hash: makeHash(year),
			title: year
		}))}
	direction="down"
	backgroundColor={theme.color.foreground}
	heightMobile={theme.dimensions.headerHeightMobile}
	top={'0px'}
	client:load
/>

<ul is="gigs-menu" data-selected={selected} class={`${yearsMenuWrapper} yearList`} style={{ overflow: 'initial' }}>
	{
		Object.entries(sortedGigs)
			.reverse()
			.map(([year, months]) => (
				<li class={MenuLi['vertical']} id={makeHash(year)}>
					<a class={yearLink}>{year}</a>
					<ul class={`${MenuWrapper['vertical']} monthList`}>
						{Object.entries(months).map(([month, gigs]) => (
							<li class={`${MenuLi['vertical']} monthItem`}>
								<a class={monthLink}>{month}</a>
								<ul class={`${MenuWrapper['vertical']} gigList`}>
									{gigs.map((gig) => (
										<li
											class={`${MenuLi['vertical']} gigItem ${gig.entry.id === selected ? 'active' : ''}`}
											data-gig={makeHash(gig.entry.id)}
										>
											<a class={gigLink} href={!selected ? `#${makeHash(gig.entry.id)}` : gig.extra.absolutePath}>
												{gig.entry.data.title}
											</a>
											{gig.entry.id === selected && (
												<ul is="artists-menu" class={artistsMenuWrapper}>
													{gig.extra.artists.map((artist) => (
														<li class={MenuLi['vertical']}>
															<a class={artistLink} href={`#${artist.entry.id}`}>
																{artist.entry.data.title}
															</a>
														</li>
													))}
												</ul>
											)}
										</li>
									))}
								</ul>
							</li>
						))}
					</ul>
				</li>
			))
	}
</ul>

<!-- 
	This is a bit of an ugly workaround.
	On the gigs page we shuffle the tiles and listen on the menu.
	On individual gig pages there are no tiles, so we shuffle this hidden list instead.
-->
{
	selected && (
		<ul id="shuffle-menu" class="hidden">
			{gigs.map((gig) => (
				<li
					id={makeHash(gig.entry.id)}
					class="hiddenItem"
					data-title={`${gig.entry.data.title} ${gig.extra.venue.data.title} ${artistsToString(gig.extra.artists)}`}
				/>
			))}
		</ul>
	)
}

<slot />

<script>
	import type Shuffle from 'shufflejs'
	import { scrollTo } from 'src/util/helpers'
	import browserHistory from 'src/util/history'
	import type { Location } from 'history'
	import { maintainSidebarScrollPosition } from 'src/util/helpers'

	maintainSidebarScrollPosition('gig')

	/**
	 * Artists menu which sits under a gig if its selected.
	 *
	 * Handles highlighting the active artist, and scrolling smoothly
	 * to the artist on click.
	 */
	class ArtistsMenu extends HTMLUListElement {
		unlisten: any

		sidebar: HTMLElement | null

		selectedArtist: Element | undefined
		links: NodeListOf<HTMLElement> | null

		constructor() {
			super()
			this.sidebar = document.querySelector<HTMLElement>('sidebar-wrapper')
			this.links = this.querySelectorAll('a')
		}

		/**
		 * Respond to the Gig layout changing the hash.
		 *
		 * Highlights the active artist.
		 *
		 * @param location
		 */
		handleURLChange(location: Location) {
			if (location.hash) {
				const newSelectedId = location.hash
				const selectedItem = this.querySelector(`[href="${newSelectedId}"]`)

				if (!selectedItem) {
					this.selectedArtist && this.selectedArtist.classList.remove('active')
					this.selectedArtist = undefined
					return
				}

				this.selectedArtist && this.selectedArtist.classList.remove('active')
				this.selectedArtist = selectedItem
				this.selectedArtist && this.selectedArtist.classList.add('active')
			} else {
				this.selectedArtist && this.selectedArtist.classList.remove('active')
				this.selectedArtist = undefined
			}
		}

		/**
		 * Scroll to an artist and hide the sidebar if it's open.
		 */
		itemClick(e: MouseEvent) {
			scrollTo(e)
			// Close sidebar on mobile
			// See: SidebarNav.astro
			// @ts-ignore
			this.sidebar.toggleSidebar()
		}

		/**
		 * Adds event listeners.
		 */
		connectedCallback() {
			this.unlisten = browserHistory?.listen((location) => this.handleURLChange(location.location))
			this.links?.forEach((link) => {
				link.addEventListener('click', (e) => this.itemClick(e))
			})
		}

		disconnectedCallback() {
			this.unlisten && this.unlisten()
		}
	}

	/**
	 * A menu of gigs.
	 *
	 * Similar to EntryMenu.astro but with subcategories for year/month.
	 *
	 * Because of these subcategories we can't Shuffle it directly, so
	 * instead we respond to shuffle events from another list.
	 */
	class GigsMenu extends HTMLUListElement {
		sidebar: HTMLElement | null
		gigLinks: NodeListOf<HTMLElement> | null
		artistsMenu: HTMLElement | null
		selected: string | null

		constructor() {
			super()
			this.sidebar = document.querySelector('sidebar-wrapper')
			this.gigLinks = this.querySelectorAll('[data-gig]')
			this.artistsMenu = this.querySelector('artists-menu')
			this.selected = this.getAttribute('data-selected')
		}

		itemClick(e: MouseEvent) {
			scrollTo(e)
			// Close sidebar on mobile
			// See: SidebarNav.astro
			// @ts-ignore
			this.sidebar.toggleSidebar()
		}

		/**
		 * Respond to shuffle events and hide gigs/years/months.
		 * @param e
		 */
		onShuffle(e: any) {
			const shuffle = e.detail as Shuffle

			// Hide the artists menu if we're shuffling
			if (shuffle.visibleItems !== shuffle.items.length && this.selected) {
				this.artistsMenu?.classList.add('hidden')
			} else {
				this.artistsMenu?.classList.remove('hidden')
			}

			shuffle?.items?.forEach((item) => {
				const gigId = item.element.id
				const sidebarItem = this.querySelector(`[data-gig="${gigId}"]`)

				const gigList = sidebarItem?.closest('.gigList')
				if (!gigList) return

				const monthList = gigList.closest('.monthList')
				if (!monthList) return

				// Hide items filtered out by shuffle
				if (!item.isVisible) {
					sidebarItem?.classList.add('hidden')
				} else {
					sidebarItem?.classList.remove('hidden')
				}

				// Hide months without any visible gigs
				const gigsInGroup = gigList.childElementCount
				const hiddenGigsInGroup = gigList.querySelectorAll('.gigItem.hidden').length

				if (gigsInGroup === hiddenGigsInGroup) {
					gigList.parentElement?.classList.add('hidden')
				} else {
					gigList.parentElement?.classList.remove('hidden')
				}

				// Hide years without any visible months
				const monthsInYear = monthList.childElementCount
				const hiddenMonthsInYear = monthList.querySelectorAll('.monthItem.hidden').length

				if (monthsInYear === hiddenMonthsInYear) {
					monthList.parentElement?.classList.add('hidden')
				} else {
					monthList.parentElement?.classList.remove('hidden')
				}
			})
		}

		connectedCallback() {
			document.addEventListener('shuffle-filter', (e: any) => this.onShuffle(e), false)
			!this.selected && this.gigLinks?.forEach((gigLink) => gigLink.addEventListener('click', (e) => this.itemClick(e)))
		}

		disconnectedCallback() {}
	}

	customElements.define('gigs-menu', GigsMenu, { extends: 'ul' })
	customElements.define('artists-menu', ArtistsMenu, { extends: 'ul' })
</script>
