---
/**
 * Menu of all gigs on the website, sorted by date and month.
 *
 * It responds to shuffle events to filter its items.
 *
 * Props:
 *  selected (optional): it will show the artists under that gig.
 */
import { loadAndFormatCollection, sortGigs } from 'src/util/collection.ts'
import {
	yearHeader,
	monthHeader,
	gigLi,
	gigLink,
	artistLink,
	yearLink,
	monthLink,
	gigsMenuWrapper,
	artistsMenuWrapper,
	backButton
} from './GigsMenu.css'
import { makeHash, artistsToString } from 'src/util/helpers'
import DropdownMenu from '../DropdownMenu'
import { theme } from 'src/Theme.css'
import ChevronLeftIcon from '~icons/bx/chevron-left'

interface Props {
	selected?: string
}

const gigs = await loadAndFormatCollection('gig')
const sortedGigs = sortGigs(gigs)

const { selected } = Astro.props
---

<DropdownMenu
	list={Object.keys(sortedGigs)
		.reverse()
		.map((year) => ({
			hash: makeHash(year),
			title: year
		}))}
	direction="down"
	backgroundColor={theme.color.foreground}
	top={'0px'}
	client:load
/>

<gigs-menu data-selected={selected}>
	{
		selected && (
			<a class={`showMobile flex ${backButton}`} href="/gigs">
				<ChevronLeftIcon /> Go to gigs home{' '}
			</a>
		)
	}
	{
		Object.entries(sortedGigs)
			.reverse()
			.map(([year, months]) => (
				<ul class={`${gigsMenuWrapper} yearList`} style={{ overflow: 'initial' }}>
					<li class={yearHeader} id={makeHash(year)}>
						<a class={yearLink}>{year}</a>
					</li>
					{Object.entries(months).map(([month, gigs]) => (
						<ul class={`${gigsMenuWrapper} monthList`}>
							<li class={monthHeader}>
								<a class={monthLink}>{month}</a>
							</li>
							{gigs.map((gig) => (
								<Fragment>
									<li
										class={`${gigLi} gigItem ${gig.entry.id === selected ? 'active' : ''}`}
										data-gig={makeHash(gig.entry.id)}
									>
										<a class={gigLink} href={!selected ? `#${makeHash(gig.entry.id)}` : gig.extra.absolutePath}>
											{gig.entry.data.title}
										</a>
									</li>
									{gig.entry.id === selected && (
										<artists-menu>
											<ul class={artistsMenuWrapper}>
												{gig.extra.artists.map((artist) => (
													<li class={gigLi}>
														<a class={artistLink} href={`#${artist.id}`}>
															{artist.data.title}
														</a>
													</li>
												))}
											</ul>
										</artists-menu>
									)}
								</Fragment>
							))}
						</ul>
					))}
				</ul>
			))
	}
</gigs-menu>

<!-- 
	This is a bit of an ugly workaround.
	On the gigs page we shuffle the tiles and listen on the menu.
	On individual gig pages there are no tiles, so we shuffle this hidden list instead.
-->
{
	selected && (
		<ul id="shuffle-menu" class="hidden">
			{gigs.map((gig) => (
				<li
					id={makeHash(gig.entry.id)}
					class="hiddenItem"
					data-title={`${gig.entry.data.title} ${gig.extra.venue.data.title} ${artistsToString(gig.extra.artists)}`}
				/>
			))}
		</ul>
	)
}

<slot />

<script>
	import type Shuffle from 'shufflejs'
	import { scrollTo } from 'src/util/helpers'
	import browserHistory from 'src/util/history'
	import type { Location } from 'history'
	import { maintainSidebarScrollPosition } from 'src/util/helpers'

	maintainSidebarScrollPosition('gig')

	/**
	 * Artists menu which sits under a gig if its selected.
	 */
	class ArtistsMenu extends HTMLElement {
		unlisten: any

		sidebar: HTMLElement | null

		selectedArtist: Element | undefined
		links: NodeListOf<HTMLElement> | null

		constructor() {
			super()
			this.sidebar = document.querySelector<HTMLElement>('sidebar-wrapper')
			this.links = this.querySelectorAll('a')
		}

		/**
		 * Respond to the Gig layout changing the hash.
		 *
		 * Highlights the active artist.
		 *
		 * @param location
		 */
		handleURLChange(location: Location) {
			if (location.hash) {
				const newSelectedId = location.hash
				const selectedItem = this.querySelector(`[href="${newSelectedId}"]`)

				if (!selectedItem) {
					this.selectedArtist && this.selectedArtist.classList.remove('active')
					this.selectedArtist = undefined
					return
				}

				this.selectedArtist && this.selectedArtist.classList.remove('active')
				this.selectedArtist = selectedItem
				this.selectedArtist && this.selectedArtist.classList.add('active')
			} else {
				this.selectedArtist && this.selectedArtist.classList.remove('active')
				this.selectedArtist = undefined
			}
		}

		/**
		 * Scroll to an artist and hide the sidebar if it's open.
		 */
		itemClick(e: MouseEvent) {
			scrollTo(e)
			// Close sidebar on mobile
			// See: SidebarNav.astro
			// @ts-ignore
			this.sidebar.toggleSidebar()
		}

		/**
		 * Adds event listeners.
		 */
		connectedCallback() {
			this.unlisten = browserHistory?.listen((location) => this.handleURLChange(location.location))
			this.links?.forEach((link) => {
				link.addEventListener('click', (e) => this.itemClick(e))
			})
		}

		disconnectedCallback() {
			this.unlisten && this.unlisten()
		}
	}

	/**
	 * A menu of gigs.
	 *
	 * Similar to EntryMenu.astro but with subcategories for year/month.
	 *
	 * Because of these subcategories we can't Shuffle it directly, so
	 * instead we respond to shuffle events from another list.
	 */
	class GigsMenu extends HTMLElement {
		sidebar: HTMLElement | null
		months: NodeListOf<HTMLElement> | null
		years: NodeListOf<HTMLElement> | null
		gigLinks: NodeListOf<HTMLElement> | null
		artistsMenu: HTMLElement | null
		selected: string | null

		constructor() {
			super()
			this.sidebar = document.querySelector('sidebar-wrapper')

			this.months = this.querySelectorAll('.monthList')
			this.years = this.querySelectorAll('.yearList')
			this.gigLinks = this.querySelectorAll('[data-gig]')
			this.artistsMenu = this.querySelector('artists-menu')

			this.selected = this.getAttribute('data-selected')
		}

		itemClick(e: MouseEvent) {
			scrollTo(e)
			// Close sidebar on mobile
			// See: SidebarNav.astro
			// @ts-ignore
			this.sidebar.toggleSidebar()
		}

		/**
		 * Respond to shuffle events and hide gigs/years/months.
		 * @param e
		 */
		onShuffle(e: any) {
			const shuffle = e.detail as Shuffle

			// Hide the artists menu if we're shuffling
			if (shuffle.visibleItems !== shuffle.items.length && this.selected) {
				this.artistsMenu?.classList.add('hidden')
			} else {
				this.artistsMenu?.classList.remove('hidden')
			}

			shuffle?.items?.forEach((item) => {
				const gigId = item.element.id
				const sidebarItem = this.querySelector(`[data-gig="${gigId}"]`)

				const monthList = sidebarItem?.parentElement
				if (!monthList) return

				const yearList = monthList.parentElement
				if (!yearList) return

				// Hide items filtered out by shuffle
				if (!item.isVisible) {
					sidebarItem?.classList.add('hidden')
				} else {
					sidebarItem?.classList.remove('hidden')
				}

				// Hide months without any visible gigs
				const gigsInGroup = monthList.childElementCount - 1
				const hiddenGigsInGroup = monthList?.querySelectorAll('.gigItem.hidden').length

				if (gigsInGroup === hiddenGigsInGroup) {
					monthList.classList.add('hidden')
				} else {
					monthList.classList.remove('hidden')
				}

				// Hide years without any visible months
				const monthsInYear = yearList.childElementCount - 1
				const hiddenMonthsInGroup = yearList.querySelectorAll('.monthList.hidden').length

				if (monthsInYear === hiddenMonthsInGroup) {
					yearList.classList.add('hidden')
				} else {
					yearList.classList.remove('hidden')
				}
			})
		}

		connectedCallback() {
			document.addEventListener('shuffle-filter', (e: any) => this.onShuffle(e), false)
			!this.selected &&
				this.gigLinks?.forEach((gigLink) => gigLink.addEventListener('click', (e) => this.itemClick(e)))
		}

		disconnectedCallback() {}
	}

	customElements.define('gigs-menu', GigsMenu)
	customElements.define('artists-menu', ArtistsMenu)
</script>
