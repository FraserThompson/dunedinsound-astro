---
/**
 *
 * Provides an element for displaying a button which opens content in a modal
 * positioned above all other elements.
 *
 * The element is duplicated so it can escape the parents stacking context.
 *
 * TODO: Options for where modal is positioned.
 *
 * Props:
 *  - className (optional): Class to add to the wrapper
 *
 * Slots:
 *  - content: The content inside the modal.
 *  - button: The content inside the button.
 */

import { modalContent, modalButton } from './Modal.css'

interface Props {
	className?: string
}

const { className = '' } = Astro.props
---

<modal-wrapper>
	<button class={`${modalButton} ${className}`} data-modalbutton aria-haspopup="true">
		<slot name="button" />
	</button>
	<div class={modalContent} data-modalcontent>
		<slot name="content" />
	</div>
</modal-wrapper>

<script>
	class Modal extends HTMLElement {
		modalButton: HTMLElement | null
		modalContent: HTMLElement | null

		constructor() {
			super()
			this.modalButton = this.querySelector('[data-modalbutton]')
			this.modalContent = this.querySelector('[data-modalcontent]')
		}

		private closeModal = () => {
			if (!this.modalContent || !this.modalButton) return

			// If already open, close and restore
			if (this.modalContent.classList.contains('open')) {
				this.modalContent.classList.remove('open')
				this.modalButton.classList.remove('active')
				this.restoreModal()
				return
			}
		}

		private openModal = () => {
			if (!this.modalContent || !this.modalButton) return

			// Get button position
			const rect = this.modalButton.getBoundingClientRect()

			// Move modal to body
			document.body.appendChild(this.modalContent)

			const isMobile = window.innerWidth <= 768

			// Position modal absolutely
			Object.assign(this.modalContent.style, {
				position: 'absolute',
				top: `${rect.bottom + window.scrollY}px`,
				left: `${!isMobile ? rect.left + window.scrollX + 'px' : 'auto'}`,
				right: `${isMobile ? '0px' : 'auto'}`,
				zIndex: 9999,
				minWidth: `${rect.width}px`
			})

			this.modalContent.classList.add('open')
			this.modalButton.classList.add('active')
		}

		private restoreModal() {
			// Restore modal to its original parent
			if (this.modalContent && this.modalButton?.parentElement) {
				this.modalButton.parentElement.appendChild(this.modalContent)
				this.modalContent.style.position = ''
				this.modalContent.style.top = ''
				this.modalContent.style.left = ''
				this.modalContent.style.zIndex = ''
				this.modalContent.style.minWidth = ''
			}
		}

		public toggleModal() {
			if (!this.modalContent) return

			// If already open, close and restore
			if (this.modalContent.classList.contains('open')) {
				this.closeModal()
			} else {
				this.openModal()
			}
		}

		connectedCallback() {
			// Attach callback for showing/hiding modal content
			this.modalButton?.addEventListener('mousedown', () => this.toggleModal())
			// If there's a sidebar and it opens or closes the modal should also close
			window.addEventListener('sidebar_close', () => this.closeModal())
			window.addEventListener('sidebar_open', () => this.closeModal())
		}

		disconnectedCallback() {
			// detach callbacks
			this.modalButton?.removeEventListener('mousedown', () => this.toggleModal())
			window.removeEventListener('sidebar_close', () => this.closeModal())
			window.removeEventListener('sidebar_open', () => this.closeModal())
		}
	}

	customElements.define('modal-wrapper', Modal)
</script>
