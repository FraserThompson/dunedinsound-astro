---
/**
 * Wrapper for a page with a sidebar navigation.
 * Slots:
 *  - sidebar: Put your sidebar menu in this.
 *  - content: Put the rest of the page in this.
 * Props:
 *  - top: Offset from the top.
 *  - scrollContext: If a context is supplied it will remember the scroll
 *    position within that context.
 */
import MenuIcon from '~icons/bx/menu'
import { sidebarWrapper, contentWrapper, menuButtonWrapper, offsetTop } from './SidebarNav.css'
import { assignInlineVars } from '@vanilla-extract/dynamic'

interface Props {
	top?: string
	scrollContext?: string
}

const { top, scrollContext } = Astro.props
---

<sidebar-wrapper data-scrollcontext={scrollContext}>
	<button id="sidebar-button" class={menuButtonWrapper}><MenuIcon /></button>
	<div
		id="sidebar"
		class={sidebarWrapper}
		style={assignInlineVars({
			[offsetTop]: top
		})}
	>
		<slot name="sidebar" />
	</div>
</sidebar-wrapper>
<div class={contentWrapper}>
	<slot name="content" />
</div>

<script async>
	// Duplicated from Helpers because we can't import with async
	const scrollToElement = (element, headerOffset, parent = window, behavior = 'smooth') => {
		if (!headerOffset) {
			element.scrollIntoView({ behavior: behavior })
		} else {
			const y = element.getBoundingClientRect().top + parent.scrollTop
			parent.scrollTo(0, y - headerOffset)
		}
	}

	class SidebarWrapper extends HTMLElement {
		sidebar
		button
		scrollContext
		scrollStorageKey = 'sidebarScroll'
		contextStorageKey = 'scrollContext'

		storedScrollPosition
		prevScrollContext

		constructor() {
			super()
			this.sidebar = this.querySelector('#sidebar')
			this.button = this.querySelector('#sidebar-button')
			this.scrollContext = this.getAttribute('data-scrollcontext')
			this.prevScrollContext = sessionStorage.getItem(this.contextStorageKey)
			this.storedScrollPosition = sessionStorage.getItem(this.scrollStorageKey)
		}

		toggleSidebar() {
			this.sidebar?.classList.toggle('open')
		}

		/**
		 * Store the current scrollbar position.
		 */
		storeScrollPosition() {
			if (this.sidebar) {
				sessionStorage.setItem(this.scrollStorageKey, this.sidebar.scrollTop.toString())
			}
		}

		/**
		 * If we have a context, store it.
		 */
		storeScrollContext() {
			this.scrollContext && sessionStorage.setItem(this.contextStorageKey, this.scrollContext)
		}

		/**
		 * Scroll to the stored scroll position if we have one.
		 */
		scrollToPosition() {
			// Retrieve the stored scroll position from sessionStorage
			// If a stored scroll position exists, scroll the sidebar to that position
			if (this.sidebar) {
				this.sidebar.scrollTop = Number(this.storedScrollPosition)
			}
		}

		connectedCallback() {
			// Button which opens and closes the isdebar
			this.button?.addEventListener('mousedown', () => this.toggleSidebar())

			// Handles scroll recall behavour
			if (this.storedScrollPosition && this.scrollContext && this.scrollContext === this.prevScrollContext) {
				// We're in the same page context: Scroll to the previous scroll position
				this.scrollToPosition()
				document.addEventListener('DOMContentLoaded', () => this.scrollToPosition())
			} else {
				// We've moved scroll contexts: Forget about the last one, store the current one
				sessionStorage.removeItem(this.scrollStorageKey)
				const activeItem = this.sidebar?.querySelector('.active')
				if (activeItem) {
					scrollToElement(activeItem, 60, this.sidebar, 'instant')
				}
			}

			// Save the current scroll context
			this.storeScrollContext()

			// And before we leave, save the scroll position
			window.addEventListener('beforeunload', () => this.storeScrollPosition())
		}

		disconnectedCallback() {
			window.removeEventListener('beforeunload', () => this.storeScrollPosition())
		}
	}

	customElements.define('sidebar-wrapper', SidebarWrapper)
</script>
