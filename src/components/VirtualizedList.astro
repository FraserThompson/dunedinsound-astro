---
/**
 * Wraps the Clusterize library in an Astro component.
 *
 * Supports ShuffleFilter (simply give its children the filter-item class.)
 *
 * Props:
 *  - rowHeight: The height each row is expected to be.
 *  - id: Optional id attribute given to container.
 *  - grid: A grid object representing how many columns per screen size.
 *  - filterOnSidebar: If true, this will respond to ShuffleFilter events and
 *    filter this components rows based on data-sidebarid attributes.
 *
 * Slots:
 *  - default: Child elements of the scrollable virtual list.
 *  - outside: Elements which are outside the scrollable virtual list.
 */
import { assignInlineVars } from '@vanilla-extract/dynamic'
import type { Grid } from './GridChild.astro'
import { marginBottom, marginBottomMobile, clusterizeScroll } from './VirtualizedList.css'
import 'node_modules/clusterize.js/clusterize.css'

interface Props {
	rowHeight?: number
	id?: string
	grid?: Grid
	filterOnSidebar?: boolean
	bottomMargin?: string
	bottomMarginMobile?: string
}

const { id, filterOnSidebar, bottomMargin, bottomMarginMobile, rowHeight = 300, grid = {} } = Astro.props
---

<virtualized-list
	id={id}
	data-rowheight={rowHeight}
	data-grid={JSON.stringify(grid)}
	data-filteronsidebar={filterOnSidebar}
>
	<slot name="outside" />
	<div
		id="scrollArea"
		class={`${clusterizeScroll}`}
		style={assignInlineVars({
			[marginBottom]: bottomMargin,
			[marginBottomMobile]: bottomMarginMobile
		})}
	>
		<div id="contentArea" class="clusterize-content">
			<slot name="default" />
		</div>
	</div>
</virtualized-list>

<script>
	import Clusterize from 'clusterize.js'
	import type { Grid } from './GridChild.astro'
	import { filterEventName, updateEventName, type FilterEventDetails, type UpdateEventDetails } from 'src/util/events'
	import { breakpoints } from 'src/Theme.css'

	class VirtualizedList extends HTMLElement {
		contentAreaId = 'contentArea'
		scrollAreaId = 'scrollArea'
		defaultRowHeight = 300
		totalCols = 12
		colCount = 1

		clusterize: Clusterize | null

		allCells: HTMLElement[]
		scrollArea: HTMLElement | null
		rowHeight: number
		rowsInBlock: number
		blocksInCluster: number
		filterOnSidebar: boolean

		constructor() {
			super()

			this.scrollArea = this.querySelector(`#${this.scrollAreaId}`)

			// Get initial list of cells before Clusterize mangles them
			this.allCells = Array.from(this.querySelectorAll(`#${this.contentAreaId} > *`))

			this.rowHeight = this.dataset.rowheight ? parseInt(this.dataset.rowheight) : this.defaultRowHeight
			this.filterOnSidebar = this.dataset.filteronsidebar ? true : false

			const grid = this.dataset.grid ? JSON.parse(this.dataset.grid) : null

			if (grid) {
				this.colCount = this.calculateColCount(grid)
			}

			// Enough rows to fill up the screen
			this.rowsInBlock = Math.round(window.innerHeight / this.rowHeight)
			this.blocksInCluster = this.rowsInBlock * 3
		}

		/**
		 * Only currently visible cells.
		 */
		get visibleCells() {
			return Array.from(this.querySelectorAll(`#${this.contentAreaId} > div`)) as HTMLElement[]
		}

		/**
		 * Calculate number of columns based on inputted grid.
		 * @param grid
		 */
		calculateColCount = (grid: Grid) => {
			const processedGrid = {
				xs: grid?.xs || this.totalCols,
				md: grid?.md || grid?.xs || this.totalCols,
				lg: grid?.lg || grid?.md || grid?.xs || this.totalCols
			}

			const windowWidth = window.innerWidth

			return windowWidth < breakpoints.xs
				? this.totalCols / processedGrid.xs
				: windowWidth < breakpoints.md
					? this.totalCols / processedGrid.md
					: windowWidth < breakpoints.lg
						? this.totalCols / processedGrid.lg
						: this.totalCols / processedGrid.lg
		}

		/**
		 * When a cluster is swapped let others know via an event.
		 */
		onClusterChange = () => {
			const detail: UpdateEventDetails = {
				visibleCells: this.visibleCells,
				allCells: this.allCells
			}
			const event = new CustomEvent(updateEventName, {
				detail
			})
			window.dispatchEvent(event)
		}

		/**
		 * Scroll to a row index.
		 * @param rowIndex
		 */
		public scrollToRow = (rowIndex: number) => {
			if (!this.scrollArea) return
			this.scrollArea.scrollTop = rowIndex * this.rowHeight
		}

		/**
		 * Scrolls to a row by element ID.
		 * @param id id of element to scroll to.
		 */
		public scrollToId = (id: string) => {
			const matchingEl = this.allCells.findIndex((el) => el.id === id)
			if (matchingEl) {
				this.scrollToRow(matchingEl)
			}
		}

		/**
		 * Respond to filter events fired by the ShuffleFilters to refresh the container.
		 * @param e
		 */
		onFilter = (e: any) => {
			const detail: FilterEventDetails = e.detail
			let filteredItems = detail.filteredItems

			// Filter our list elements to match the filtered sidebar elements if that's what we're doing
			if (this.filterOnSidebar) {
				filteredItems = this.allCells.filter((el) => {
					const thisCellsSidebarId = el.dataset.sidebarid
					if (!thisCellsSidebarId) return
					return filteredItems.find((el) => el.dataset.sidebarid === thisCellsSidebarId)
				})
			}

			if (this.colCount > 1) {
				this.updateGrid(filteredItems)
			} else {
				this.updateList(filteredItems)
			}

			if (this.scrollArea) this.scrollArea.scrollTop = 0
		}

		/**
		 * Update for list cases.
		 * @param cells
		 */
		updateList = (cells: HTMLElement[]) => {
			this.clusterize?.update(cells.map((cell) => cell.outerHTML))
		}

		/**
		 * Update for grid cases.
		 * @param cells
		 */
		updateGrid = (cells: HTMLElement[]) => {
			const rowElements: HTMLElement[] = []
			let currentRow: HTMLElement[] = []

			const style = `display: grid; grid-template-columns: repeat(${this.colCount}, 1fr); height: ${this.rowHeight}px;`

			for (let i = 0; i < cells.length; i++) {
				if (cells[i].classList.contains('hidden')) {
					continue
				}

				currentRow.push(cells[i])

				// If we've filled it up with the desired number of columns, move to a new row.
				if (currentRow.length === this.colCount) {
					const rowDiv = document.createElement('div')
					rowDiv.style = style
					currentRow.forEach((el) => rowDiv.appendChild(el))
					rowElements.push(rowDiv)
					currentRow = []
				}
			}

			// If there's anything left in the last row.
			if (currentRow.length > 0) {
				const rowDiv = document.createElement('div')
				rowDiv.style = `display: grid; grid-template-columns: repeat(${currentRow.length}, 1fr); height: ${this.rowHeight}px;`
				currentRow.forEach((el) => rowDiv.appendChild(el))
				rowElements.push(rowDiv)
			}

			this.clusterize?.update(rowElements.map((cell) => cell.outerHTML))
		}

		connectedCallback() {
			this.clusterize = new Clusterize({
				scrollId: this.scrollAreaId,
				contentId: this.contentAreaId,
				rows_in_block: this.rowsInBlock,
				blocks_in_cluster: this.blocksInCluster,
				no_data_text: 'No results match these filters.',
				callbacks: {
					clusterChanged: this.onClusterChange
				}
			})

			// If there's more than one column we need to initizialize it as a grid.
			if (this.colCount > 1) {
				this.updateGrid(this.allCells)
			}

			window.addEventListener(filterEventName, this.onFilter)
		}

		disconnectedCallback() {
			this.clusterize?.destroy()
			window.removeEventListener(filterEventName, this.onFilter)
		}
	}

	customElements.define('virtualized-list', VirtualizedList)
</script>
