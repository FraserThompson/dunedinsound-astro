---
/**
 * Encapsulates the filter and sort elements for Filtirz.
 * Also initializes the Filtizr board.
 *
 * Props:
 *  - layout: The layout to use (check filtr docs) (default: sameSize)
 *  - className: Optional classname to add
 *
 * The filter board needs the filter-container class and the items need filtr-item.
 *
 * Create filter child elements inside this component. Wrap your filters in .filterGroup.
 *
 * Then follow filterizr docs to add search/filters/sorts.
 *
 * A 'shuffle-filter' event is emitted to document on filter.
 * e.detail contains:
 *  - items: The full list of items in the board
 *  - filteredItems: The list of items after filtering.
 */

import LoadingSpinner from './LoadingSpinner'
import { shuffleFilter } from './ShuffleFilters.css'
import type { Layout } from 'filterizr/dist/types'

interface Props {
	layout?: Layout
	className?: string
}

const { layout = 'sameSize', className = '' } = Astro.props
---

<shuffle-filters data-layout={layout} class={`${shuffleFilter} ${className}`}>
	<slot />
	<div class="loading-wrapper" style={{ position: 'fixed', marginTop: '100px', marginLeft: '50%' }}>
		<LoadingSpinner />
	</div>
</shuffle-filters>

<script>
	import Filterizr from 'filterizr'
	import type { Layout } from 'filterizr/dist/types'
	import { debounce } from 'throttle-debounce'

	class ShuffleFilters extends HTMLElement {
		filtrInstance: Filterizr
		filtrElement: HTMLElement | null

		loadingSpinner: HTMLElement | null

		itemSelector: string
		boardSelector: string
		layout: Layout

		oldValue: string

		constructor() {
			super()

			this.itemSelector = '.filtr-item'
			this.boardSelector = '.filter-container'
			this.layout = this.getAttribute('data-layout') as Layout

			this.filtrElement = document.querySelector(this.boardSelector)
			this.loadingSpinner = this.querySelector('.loading-wrapper')

			this.filtrInstance = new Filterizr(this.boardSelector, {
				gridItemsSelector: this.itemSelector,
				animationDuration: 0.1,
				multifilterLogicalOperator: 'and',
				layout: this.layout,
				callbacks: {
					onInit: () => {
						// Hide until it's initialized
						if (this.filtrElement) this.filtrElement.style.display = 'flex'
						if (this.loadingSpinner) this.loadingSpinner.style.display = 'none'
					},
					onSortingEnd: this.onChange,
					onShufflingEnd: this.onChange,
					onFilteringEnd: this.onChange
				}
			})
		}

		// Emits event when something changes.
		onChange = () => {
			const event = new CustomEvent('shuffle-filter', {
				detail: {
					items: this.filtrElement?.querySelectorAll(this.itemSelector),
					filteredItems: this.filtrElement?.querySelectorAll(`${this.itemSelector}:not(.filteredOut)`)
				}
			})
			document.dispatchEvent(event)
		}

		connectedCallback() {
			const selectFilters = this.querySelectorAll('select:not([data-sortOrder])')
			const sorters = this.querySelectorAll('select[data-sortOrder]')
			const search = this.querySelector('input[data-search]')

			// Searches don't trigger the callbacks so we trigger a sort.
			search?.addEventListener(
				'input',
				debounce(300, () => {
					// If we're in a sidebar we should scroll that to the top.
					// Else the window.
					const sidebar = document.querySelector('#sidebar-menu')
					if (sidebar && this.filtrElement?.closest('#sidebar-menu') && sidebar.scrollTop !== 0) {
						sidebar.scrollTo(0, 0)
					} else if (window.scrollY !== 0) {
						window.scrollTo(0, 0)
					}
					this.filtrInstance.sort('index', 'asc')
				})
			)

			// Input type search clear doesn't trigger refilter, so we do it.
			search?.addEventListener('input', (e) => {
				const target = e.target as HTMLInputElement | undefined
				target?.value === '' && this.filtrInstance.search('')
			})

			// So we can filter with select elements
			selectFilters.forEach((el: HTMLSelectElement) =>
				el.addEventListener('change', (e) => {
					// Untoggle last filter
					if (this.oldValue) {
						this.filtrInstance.toggleFilter(this.oldValue)
					}
					const target = e.target as HTMLSelectElement
					this.oldValue = target.value
					this.filtrInstance.toggleFilter(target.value)
				})
			)

			// So we can control sort order per sorting element with an attribute
			sorters.forEach((el: HTMLSelectElement) =>
				el.addEventListener('change', (e) => {
					const target = e.target as HTMLSelectElement
					const selectedOption = target.options[target.selectedIndex]
					const sortOrder = selectedOption.dataset.order as 'asc' | 'desc' | undefined
					this.filtrInstance.sort(target.value, sortOrder || 'asc')
				})
			)
		}

		disconnectedCallback() {
			this.filtrInstance?.destroy()
		}
	}

	customElements.define('shuffle-filters', ShuffleFilters)
</script>
