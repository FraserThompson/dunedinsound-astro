---
/**
 * Encapsulates filter, sort, and search functionality for elements on the page.
 *
 * To use give the items you want to be filterable the class 'filter-item'.
 * If you want the items to also be sortable (eg. reorderable) their container
 * must have the class 'filter-container'.
 *
 * Other components can listen for the 'shuffle-filter' event to respond when
 * this component filters stuff.
 *
 * Props:
 *  - search (optional): Supply a placeholder string to enable searching of the text inside elements.
 *    (additional searchable text can be defined with data-searchable on elements)
 *  - sort (optional): Array of Sorters
 *  - filter (optional): Array of Filters
 *  - className (optional): Class to add to the wrapper
 *  - openSearchWithSidebar(optional): If true, all filters will be hidden on mobile until the
 *    sidebar is opened. This will also hide filters/sorters inside a button which pops a modal.
 */

import { shuffleFilter, modalFiltersWrapper, dropdownButton } from './ShuffleFilters.css'
import { searchboxWrapper } from './SearchBox.css'
import SortIcon from '~icons/iconoir/sort'
import SearchIcon from '~icons/iconoir/search'
import FilterIcon from '~icons/iconoir/filter'
import GlobeIcon from '~icons/iconoir/globe'
import Modal from './Modal.astro'

export interface Sorter {
	value: string
	order: string
	title: string
}

export interface Filter {
	value?: string
	values?: string[][]
	title: string
	checkedTitle?: string
	icon?: string
	type: 'select' | 'checkbox'
}

interface Props {
	search?: string
	sort?: Sorter[]
	filter?: Filter[]
	className?: string
	style?: Partial<CSSStyleDeclaration>
	openSearchWithSidebar?: boolean
}

const { openSearchWithSidebar, search, sort, filter, className = '', style } = Astro.props
---

<shuffle-filters class:list={[shuffleFilter, className]} style={style}>
	{
		search && (
			<label
				class={`${searchboxWrapper} fixedBottomMobile flex ${openSearchWithSidebar ? 'openWithSidebar bottom' : ''}`}
			>
				<SearchIcon class="hideMobile" />
				<input type="search" name="search" placeholder={search} />
			</label>
		)
	}
	{
		!openSearchWithSidebar && sort && (
			<label>
				<SortIcon aria-label="Sort by" />
				<select data-sort>
					{sort.map((sort) => (
						<option value={sort.value} data-order={sort.order}>
							{sort.title}
						</option>
					))}
				</select>
			</label>
		)
	}
	{
		!openSearchWithSidebar &&
			filter?.map((filter) =>
				filter.type !== 'select' ? (
					<label>
						<input name={filter.value} value={filter.value} type={filter.type} />
						{!filter.icon ? filter.title : filter.icon === 'globe' && <GlobeIcon />}
					</label>
				) : (
					<label class="flex">
						{!filter.icon ? filter.title : filter.icon === 'globe' && <GlobeIcon />}
						<select name={filter.title} data-filter>
							<option value="">All</option>
							{filter.values?.map(([title, value]) => (
								<option value={value}>{title}</option>
							))}
						</select>
					</label>
				)
			)
	}
	{
		openSearchWithSidebar && (sort || filter) && (
			<Modal className={`${openSearchWithSidebar ? dropdownButton + ' openWithSidebar top' : ''}`}>
				<FilterIcon slot="button" />
				<div slot="content" class={`${modalFiltersWrapper}`}>
					{sort && (
						<label>
							<SortIcon aria-label="Sort by" />
							<select data-sort>
								{sort?.map((sort) => (
									<option value={sort.value} data-order={sort.order}>
										{sort.title}
									</option>
								))}
							</select>
						</label>
					)}
					{filter?.map((filter) =>
						filter.type !== 'select' ? (
							<label>
								<input name={filter.value} value={filter.value} type={filter.type} />
								{!filter.icon ? filter.title : filter.icon === 'globe' && <GlobeIcon />}
							</label>
						) : (
							<label class="flex">
								{!filter.icon ? filter.title : filter.icon === 'globe' && <GlobeIcon />}
								<select name={filter.title} data-filter>
									<option value="">All</option>
									{filter.values?.map(([title, value]) => (
										<option value={value}>{title}</option>
									))}
								</select>
							</label>
						)
					)}
				</div>
			</Modal>
		)
	}
</shuffle-filters>

<script>
	import { filterEventName, type FilterEventDetails } from 'src/util/events'
import { stringNormalize } from 'src/util/names'

	class ShuffleFilters extends HTMLElement {
		htmlElements: HTMLElement[]
		filteredElements: HTMLElement[]
		sidebar: HTMLElement | null
		container: HTMLElement | null

		searchValue: string

		sortValue: string
		sortOrder: number

		filters: string[]
		selectFilters: {}

		searchElement: HTMLElement | null
		selectFilterElements: NodeListOf<HTMLElement> | null
		checkboxFilterElements: NodeListOf<HTMLElement> | null
		sortElements: NodeListOf<HTMLElement> | null

		constructor() {
			super()

			const itemSelector = '.filter-item'
			const containerSelector = '.filter-container'

			this.htmlElements = Array.from(document.querySelectorAll(itemSelector))
			this.container = document.querySelector(containerSelector)
			this.sidebar = document.querySelector('#sidebar-menu')

			this.filters = []
			this.filteredElements = []
			this.selectFilters = {}

			this.searchValue = ''
			this.sortValue = ''
			this.sortOrder = 1

			this.searchElement = this.querySelector('input[type=search]')
			this.selectFilterElements = this.querySelectorAll('select[data-filter]')
			this.checkboxFilterElements = this.querySelectorAll('input[type=checkbox]')
			this.sortElements = this.querySelectorAll('select[data-sort]')
		}

		// Combines the results of all filters and determines whether an item should be filtered
		filterItem = (item: HTMLElement) => {
			const lowerSearch = stringNormalize(this.searchValue)
			const elementSearchableText = `${item.innerText}${item.dataset.searchable || ''}`
			const searchResult = stringNormalize(elementSearchableText).includes(lowerSearch)
			const itemCategories = item.dataset.category?.split(',')
			const combinedFilters = [...this.filters, ...Object.values(this.selectFilters)] as string[]
			const filterResult =
				combinedFilters.length > 0
					? combinedFilters.every((filter) => itemCategories && itemCategories.includes(filter))
					: true

			const visible = searchResult && filterResult

			if (visible) {
				item.classList.remove('hidden')
			} else {
				item.classList.add('hidden')
			}

			return visible
		}

		// Toggle a checkbox filter on and off
		toggleFilter = (value: string) => {
			if (this.filters.includes(value)) {
				this.filters = this.filters.filter((currentFilter) => currentFilter !== value)
			} else {
				this.filters = [...this.filters, value]
			}
		}

		// Set a select filter
		selectFilter = (title: string, value: string) => {
			const newFilters = { ...this.selectFilters }
			if (!value) {
				delete newFilters[title]
			} else {
				newFilters[title] = value
			}
			this.selectFilters = newFilters
		}

		// Filter and sort items based on current filters and sorts
		filterItems = () => {
			const filtered = this.htmlElements.filter((item) => this.filterItem(item))

			if (this.sortValue) {
				this.filteredElements = filtered.sort((a, b) => {
					const sortA = a.dataset[this.sortValue] || ''
					const sortB = b.dataset[this.sortValue] || ''
					const aNumber = parseInt(sortA)
					const bNumber = parseInt(sortB)

					if (typeof aNumber === 'number') {
						return (aNumber - bNumber) * this.sortOrder
					} else {
						return sortA.localeCompare(sortB)
					}
				})

				if (this.container) {
					// Remove all current filter-items
					this.htmlElements.forEach((item) => {
						if (item.parentElement === this.container) {
							this.container?.removeChild(item)
						}
					})
					// Append filtered and sorted items in new order
					this.filteredElements.forEach((item) => {
						this.container?.appendChild(item)
					})
				}
			} else {
				this.filteredElements = filtered
			}

			// Scroll to top on filtering
			this.sidebar?.scrollTo(0, 0)

			this.onChange()
		}

		// When anything changes let everyone know
		onChange = () => {
			const detail: FilterEventDetails = {
				items: this.htmlElements,
				searchValue: this.searchValue,
				filteredItems: this.filteredElements
			}
			const event = new CustomEvent(filterEventName, {
				detail
			})
			window.dispatchEvent(event)
		}

		onSearch = (e) => {
			const target = e.currentTarget
			this.searchValue = target.value
			this.filterItems()
		}

		onSelectFilter = (e) => {
			const target = e.target
			this.selectFilter(target.title, target.value)
			this.filterItems()
		}

		onCheckboxFilter = (e) => {
			const target = e.currentTarget
			this.toggleFilter(target.value)
			this.filterItems()
		}

		onSort = (e) => {
			const target = e.target
			this.sortValue = target.value
			this.sortOrder = target.dataset.order === 'asc' ? 1 : -1
			this.filterItems()
		}

		connectedCallback() {
			// attach callbacks for search, sort, filter elements
			this.searchElement?.addEventListener('input', this.onSearch)
			this.selectFilterElements &&
				Array.from(this.selectFilterElements).map((el) => el.addEventListener('change', this.onSelectFilter))
			this.checkboxFilterElements &&
				Array.from(this.checkboxFilterElements).map((el) => el.addEventListener('input', this.onCheckboxFilter))
			this.sortElements && Array.from(this.sortElements).map((el) => el.addEventListener('change', this.onSort))
		}

		disconnectedCallback() {
			// detach callbacks for search, sort, filter elements
			this.searchElement?.removeEventListener('input', this.onSearch)
			this.selectFilterElements &&
				Array.from(this.selectFilterElements).map((el) => el.removeEventListener('change', this.onSelectFilter))
			this.checkboxFilterElements &&
				Array.from(this.checkboxFilterElements).map((el) => el.removeEventListener('input', this.onCheckboxFilter))
			this.sortElements && Array.from(this.sortElements).map((el) => el.removeEventListener('change', this.onSort))
		}
	}

	customElements.define('shuffle-filters', ShuffleFilters)
</script>
