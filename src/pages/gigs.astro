---
import { loadAndFormatCollection } from 'src/util/collection'
import SidebarLayout from 'src/layouts/base/SidebarLayout.astro'
import GigsMenu from 'src/components/gig/GigsMenu.astro'
import GigTile from 'src/components/gig/GigTile.astro'
import VirtualizedList from 'src/components/VirtualizedList.astro'
import SeriesTile from 'src/components/gig/SeriesTile.astro'
import ShuffleFilters from 'src/components/ShuffleFilters.astro'

const gigs = await loadAndFormatCollection('gig')
const series = await loadAndFormatCollection('series')
---

<SidebarLayout
	hasSubheaderBottomMobile={true}
	poo={{ title: 'Gigs', image: gigs[0].extra.cover?.[0]?.src }}
	hideFooter={true}
>
	<ShuffleFilters slot="subheaderTopDesktop" search="Filter gigs by title, artist, venue" />
	<GigsMenu slot="sidebarMenu" transition:persist />
	<VirtualizedList slot="content" id="gigs" filterOnSidebar={true}>
		<div slot="outside">
			{series.map((serie) => <SeriesTile series={serie} />)}
		</div>
		{gigs.map((gig) => <GigTile gig={gig} responsiveImageSizes="full" />)}
	</VirtualizedList>
</SidebarLayout>

<script>
	import { filterEventName, updateEventName, type FilterEventDetails } from 'src/util/events'
	import { scrollToElement } from 'src/util/helpers'
	import { stringNormalize } from 'src/util/names'

	document.addEventListener('astro:page-load', () => {
		// See SidebarNav.astro
		const sidebar = document.querySelector('sidebar-wrapper')
		const sidebarMenu = sidebar?.querySelector('#sidebar-menu')

		// See VirtualizedList.astro
		const virtualizedList = document.querySelector('virtualized-list')

		const seriesTiles: NodeListOf<HTMLElement> = document.querySelectorAll('.seriesTile')

		/**
		 * Highlights gig in the sidebar when its scrolled over on the main page.
		 */
		const callback = (entries: IntersectionObserverEntry[]) => {
			entries.forEach((entry) => {
				const sidebarItem = sidebar?.querySelector<HTMLElement>(`[href="#${entry.target.id}"]`)
				if (entry.isIntersecting && sidebarItem) {
					sidebarItem?.classList.add('active')
					scrollToElement(sidebarItem, undefined, sidebarMenu || undefined, 'smooth', 'center')
				} else {
					sidebarItem?.classList.remove('active')
				}
			})
		}

		// Since Clusterize adds and removes elements from the DOM
		// we have to add observers for new gigs when it changes.
		// See VirtualizedList.tsx
		const options = {
			rootMargin: '-5% 0px -95% 0px'
		}

		const observer = new IntersectionObserver(callback, options)

		const observeGigs = (elements?: HTMLElement[]) => {
			const gigs: HTMLElement[] = elements || Array.from(document.querySelectorAll('#gigs .tile'))
			gigs?.forEach((el) => {
				observer.observe(el)
			})
		}

		window.addEventListener(updateEventName, (e: any) => {
			// Stop observing if we've started scrolling to a year.
			// This is to avoid it being centered. Also kinda bad, should improve.
			// @ts-expect-error
			if (!window.scrollingToYear) {
				observeGigs()
			} else {
				setTimeout(() => {
					// @ts-expect-error
					virtualizedList?.scrollArea.addEventListener(
						'scroll',
						() => {
							observeGigs()
						},
						{ once: true }
					)
				}, 3000)
			}
		})

		// Observe loaded elements on page load
		setTimeout(() => {
			observeGigs()
		}, 200)

		// We want to show a series at the top if there's one, so check on filter.
		window.addEventListener(filterEventName, (e: any) => {
			// Hidden by default
			seriesTiles.forEach((el) => el.classList.add('hidden'))
			// Find if there's exactly one match
			const detail: FilterEventDetails = e.detail
			const query = stringNormalize(detail.searchValue)
			const seriesMatches = Array.from(seriesTiles).filter((el) => stringNormalize(el.dataset.title)?.includes(query))
			// Show that one match
			if (seriesMatches.length === 1) {
				seriesMatches[0].classList.remove('hidden')
			}
		})

		if (window.location.hash) {
			// @ts-expect-error
			virtualizedList?.scrollToId(window.location.hash.substring(1))
		}
	})
</script>
